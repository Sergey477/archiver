# archiver

Чтобы скомпилировать файл выполнить из корня проекта:

cmake -S src -B build
cd build
make archiver

Чтобы заархивировать файлы надо запустить программу archiver с флагом -c archive_name file1, [file2, file3...]
Например из корня проекта:

./build/archiver -c test_objects/archive test_objects/main.pdf test_objects/shrek.jpg

После этого в папке test_objects появится файл archive.

Для того чтобы разархивировать файл нужно запустить программу с флагом -d archive_name. Файлы будут записаны в папку откуда будет вызвана программа.
Например если теперь запустить из корня проекта:

./build/archiver -d test_objects/archive

То в корне проекта появится файлы shrek.jpg и main.pdf.
Чтобы убедиться, что файлы совпадают теперь можно запустить из корня проекта:

diff main.pdf test_objects/main.pdf
diff shrek.jpg test_objects/shrek.jpg

И убедиться что различий не нашлось.

Проект архиватора написан на основе алгоритма Хаффмана.
В каждом файле считается частота каждого байта и по этим данным строится самое оптимальное дерево для того чтобы заменить каждый байт последовательностью битов.
Затем данные в файл архива записывается имя файла и данные о частотах символов. Затем вместо каждого байта записывается сопоставленная ему битовая последовательность.
В конце указывается конец ли это, либо что дальше есть еще файлы.

При разархивации по данным о частотах байтов однозначно восстанавливается какому байту какая последовательность сопоставлена, а далее просто линейным проходом разархивируется файл.
Также я написал обработку ошибок во время чтения/записи (но не всю, например если скормить архиватору неправильный архив будет плохо).